<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Game with Lanes</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black; /* Background color for fallback */
        }

        canvas {
            display: block;
            width: 80vw;
            height: 100vh;
        }

        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            font-family: Arial, sans-serif;
            z-index: 10;
        }

        .menu button {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 24px;
            cursor: pointer;
            margin: 10px;
            border-radius: 5px;
        }

        .menu button:hover {
            background-color: #218838;
        }

        #scoreBoard {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
            z-index: 5;
        }

        #lives {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
            z-index: 5;
        }

        .lostLife {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="scoreBoard">Score: 0</div>
    <div id="lives">Lives: 5</div>
    <canvas id="gameCanvas"></canvas>
    <div class="menu" id="menu">
        <h1>Typing Game</h1>
        <button id="startButton">Start Game</button>
        <button id="closeButton">Close Game</button>
    </div>

    <script>
        // Setup canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.8; // 80% of screen width
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial resize on load

        let words = ['sword', 'shield', 'enemy', 'battle', 'hero'];
        let activeWords = [];
        let score = 0;
        let lives = 5;
        let lanes = [0, 1, 2, 3, 4]; // 5 lanes
        let laneHeight = canvas.height / lanes.length; // Equal lane height
        let wordSpeed = 9; // Slower speed
        let gameActive = false;
        let lastSpawnTime = 0; // Keep track of last word spawn time
        let isDizzy = false; // Track if a character is dizzy
        const characterImages = {};
        const characterCount = 5; 
        const characterSize = canvas.height / 5; // Calculate character size based on screen height

        // Load background image
        const backgroundImage = new Image();
        backgroundImage.src = 'https://images.unsplash.com/photo-1601370690183-1c7796ecec61?fm=jpg&q=60&w=3000&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxleHBsb3JlLWZlZWR8M3x8fGVufDB8fHx8fA%3D%3D';

        // Load character images (Placeholder)
        for (let i = 1; i <= characterCount; i++) {
            const img = new Image();
            img.src = `character${i}.png`; // Ensure you have character images in the right path
            characterImages[`character${i}`] = img;
        }

        // Initialize words with a fixed delay of 4 seconds
        function spawnWords() {
            const now = Date.now();
            if (now - lastSpawnTime > 4000) { // 4-second interval
                let availableLane = lanes[Math.floor(Math.random() * lanes.length)];
                let wordObj = {
                    word: words[Math.floor(Math.random() * words.length)],
                    typed: '',
                    x: canvas.width,
                    y: availableLane * laneHeight + laneHeight / 2 // Set Y based on lane
                };
                activeWords.push(wordObj);
                lastSpawnTime = now; // Update the last spawn time
            }
        }

        function drawCharacter(lane, isDizzy) {
            const img = characterImages[`character${lane + 1}`];
            const x = 0; // Fixed position at the start of the canvas
            const y = lane * laneHeight + laneHeight / 2; // Centered vertically in the lane

            // Draw character box
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Semi-transparent background for character box
            ctx.fillRect(x - 10, y - characterSize / 2, characterSize + 20, characterSize); // Box dimensions

            if (img) {
                // Apply shaking effect if character is dizzy
                const shakeOffset = isDizzy ? (Math.sin(Date.now() / 100) * 5) : 0;
                ctx.drawImage(img, x + shakeOffset, y - characterSize / 2, characterSize, characterSize); // Adjust size and position of characters
            }
        }

        function drawWords() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous drawings
            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height); // Draw background image

            activeWords.forEach((wordObj) => {
                const { word, typed, x, y } = wordObj;

                // Draw the word
                for (let i = 0; i < word.length; i++) {
                    ctx.fillStyle = i < typed.length ? (word[i] === typed[i] ? 'green' : 'red') : 'white'; // Change color based on typing
                    ctx.font = '50px Arial';
                    ctx.fillText(word[i], x + i * 40, y); // Adjust x position for each letter
                }

                // Move word left
                wordObj.x -= wordSpeed; 

                // Check for collision with character box
                if (wordObj.x < characterSize) { // Assuming the character is at the left side
                    const laneIndex = Math.floor(y / laneHeight);
                    if (laneIndex >= 0 && laneIndex < lanes.length) {
                        isDizzy = true; // Set character as dizzy
                        lives--; // Decrease lives only when word reaches character box

                        // Flash the lives indicator red when losing a life
                        const livesElement = document.getElementById('lives');
                        livesElement.classList.add('lostLife');
                        setTimeout(() => livesElement.classList.remove('lostLife'), 500); // Remove the class after 500ms

                        if (lives <= 0) {
                            alert('Game Over! You missed too many words.');
                            resetGame();
                        }
                        activeWords.shift(); // Remove the missed word
                    }
                }

                // If the word goes off the canvas
                if (wordObj.x < -200) {
                    activeWords.shift(); // Remove the missed word but don't decrease lives
                }
            });

            // Draw all characters at their respective lanes
            lanes.forEach(lane => drawCharacter(lane, isDizzy)); // Initial drawing, apply dizzy effect when needed
            isDizzy = false; // Reset dizzy effect after draw

            // Update score and lives on the screen
            document.getElementById('scoreBoard').innerText = 'Score: ' + score;
            document.getElementById('lives').innerText = 'Lives: ' + lives;
        }

        function gameLoop() {
            if (gameActive) {
                spawnWords(); // Spawn words at 4-second intervals
                drawWords(); // Draw the words on the canvas
                requestAnimationFrame(gameLoop);
            }
        }

        function startGame() {
            document.getElementById('menu').style.display = 'none'; // Hide menu
            gameActive = true; // Set game to active
            score = 0; // Reset score
            lives = 5; // Set lives to 5
            activeWords = []; // Clear active words
            gameLoop(); // Start the game loop
        }

        function resetGame() {
            gameActive = false; // Set game to inactive
            document.getElementById('menu').style.display = 'block'; // Show menu again
            activeWords = []; // Clear active words
        }

        function closeGame() {
            alert("Thank you for playing! Please close the tab manually.");
        }

        // Event listeners for buttons
        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('closeButton').addEventListener('click', closeGame);

        // Keyboard input for typing
        window.addEventListener('keydown', (e) => {
            if (gameActive && activeWords.length > 0) {
                let firstWord = activeWords[0]; // Always focus on the first word
                if (e.key === firstWord.word[firstWord.typed.length]) {
                    firstWord.typed += e.key; // Add correct letter
                    if (firstWord.typed === firstWord.word) {
                        score++; // Increase score
                        activeWords.shift(); // Remove the word from the list after it's fully typed
                    }
                }
            }
        });
    </script>
</body>
</html>
